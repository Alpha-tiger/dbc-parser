%include {

#include <assert.h>
#include <string.h>
#include "dbc-info.h"
#include "dbc_parser_priv.h"

extern void *DbcParserAlloc(void *(*mallocProc)(size_t));
extern void DbcParser(void *yyp, int yymajor, char *yyminor, dbc_state_t *state);
extern void DbcParserFree(void *p, void (*freeProc)(void*));

#ifdef DBC_TRACE
extern void DbcParserTrace(FILE *TraceFILE, char *zTracePrompt);
#endif

#undef NDEBUG

_Pragma("GCC diagnostic push")
_Pragma("GCC diagnostic ignored \"-Wsign-compare\"")

}

%name DbcParser

%token_prefix TK_

%token_type { gchar * }
%token_destructor
{
    (void)state;
    (void)yypParser;

    g_free($$);
}

%extra_argument { dbc_state_t* state }

%syntax_error
{
    (void)yyminor;

    gboolean first = TRUE;
    GString *msg = g_string_new(NULL);

    g_string_append_printf(
        msg,
        "%s:%d:%d: syntax error: unexpected %s, expecting ",
        state->file->filepath,
        state->lloc.first_line,
        state->lloc.first_column,
        yyTokenName[yymajor]);

    for (YYCODETYPE token = 0; token < YYNTOKEN; ++token)
    {
        const YYACTIONTYPE action = yy_find_shift_action(token, yypParser->yytos->stateno);

        if ((action == YY_ACCEPT_ACTION) ||
            (action <= YY_MAX_SHIFT) ||
            ((action >= YY_MIN_SHIFTREDUCE) && (action <= YY_MAX_SHIFTREDUCE)) ||
            ((action >= YY_MIN_REDUCE) && (action <= YY_MAX_REDUCE)))
        {
            if (!first)
                g_string_append(msg, ", ");
            g_string_append(msg, yyTokenName[token]);
            first = FALSE;
        }
    }

    g_free(state->parse_error);
    state->parse_error = g_string_free(msg, FALSE);
}

%parse_failure
{
    g_free(state->parse_error);
    state->parse_error = g_strdup("Parse failure");
}

%stack_overflow
{
    g_free(state->parse_error);
    state->parse_error = g_strdup("Stack overflow");
}

%nonassoc AT ATTR_ENUM ATTR_FLOAT ATTR_HEX ATTR_INT ATTR_STRING BO BO_TX_BU BU FLOAT LEFT_BRACKET LEFT_PARENTHESIS PIPE RIGHT_BRACKET RIGHT_PARENTHESIS SG UNKNOWN .

%start_symbol spec

spec ::= version
         new_symbols
         bus_speed
         bus_units
         value_tables
         .

version ::= .
version ::= VERSION TEXT(str) .
{
    state->file->version = str;
}

new_symbols ::= .
new_symbols ::= NS COLON new_symbol_names .

new_symbol_names ::= .
new_symbol_names ::= new_symbol_names new_symbol_name.

new_symbol_name ::= NAME .
new_symbol_name ::= NS_DESC .
new_symbol_name ::= CM .
new_symbol_name ::= VAL .
new_symbol_name ::= VAL_TABLE .
new_symbol_name ::= BA .
new_symbol_name ::= BA_REL .
new_symbol_name ::= BA_DEF .
new_symbol_name ::= BA_DEF_REL .
new_symbol_name ::= BA_DEF_DEF .
new_symbol_name ::= BA_DEF_DEF_REL .
new_symbol_name ::= BU_BO_REL .
new_symbol_name ::= BU_SG_REL .
new_symbol_name ::= BU_EV_REL .
new_symbol_name ::= SIG_VALTYPE .
new_symbol_name ::= SIG_GROUP .
new_symbol_name ::= SG_MUL_VAL .
new_symbol_name ::= BO_TX_BU .
new_symbol_name ::= EV .
new_symbol_name ::= EV_DATA .
new_symbol_name ::= ENVVAR_DATA .
new_symbol_name ::= SGTYPE .
new_symbol_name ::= SIG_TYPE_REF .
new_symbol_name ::= SGTYPE_VAL .
new_symbol_name ::= SIGTYPE_VALTYPE .
new_symbol_name ::= BA_DEF_SGTYPE .
new_symbol_name ::= BA_SGTYPE .
new_symbol_name ::= CAT_DEF .
new_symbol_name ::= CAT .
new_symbol_name ::= FILTER .

bus_speed ::= BS COLON .
bus_speed ::= BS COLON UINT .
bus_speed ::= BS COLON UINT COLON UINT COMMA UINT .

bus_units ::= BU COLON maybe_names .

%type maybe_names { GSList * }
%destructor maybe_names { g_slist_free_full($$, g_free); }

maybe_names(r) ::= .          { r = NULL; }
maybe_names(r) ::= names(v) . { r = v; }

%type names { GSList * }
%destructor names { g_slist_free_full($$, g_free); }

names(r) ::= name(v) .          { r = g_slist_prepend(NULL, v); }
names(r) ::= names(l) name(v) . { r = g_slist_prepend(l, v); }

%type name { gchar * }
%destructor name { g_free($$); }

name(r) ::= NAME(v) . { r = v; }
name(r) ::= MUX(v) .  { r = v; }

value_tables ::= .
value_tables ::= value_tables value_table .

value_table ::= VAL_TABLE name values SEMICOLON .

%type values { GArray * }
%destructor values { g_array_free($$, TRUE); }

values(r) ::= .
{
    r = g_array_new(TRUE, TRUE, sizeof(value_string));
    g_array_set_clear_func(r, free_value_string);
}

values(r) ::= values(a) value(v) .
{
    r = g_array_append_val(a, v);
}

%type value { value_string }
%destructor value { free_value_string(&($$)); }

value(r) ::= integer(v) TEXT(t) .
{
    r.value  = v;
    r.strptr = t;
}

%type integer { gint64 }

integer(r) ::= UINT(v) .       { r = strtoull(v, NULL, 10); g_free(v); }
integer(r) ::= PLUS UINT(v) .  { r = strtoull(v, NULL, 10); g_free(v); }
integer(r) ::= MINUS UINT(v) . { r = 0 - strtoull(v, NULL, 10); g_free(v); }
integer(r) ::= FLOAT(v) .      { r = (gint64)strtod(v, NULL); g_free(v); }

%code {

_Pragma("GCC diagnostic pop")

#include "dbc_scanner_lex.h"
#include "dbc_parser.h"

dbc_file_t *dbc_read(const gchar *filename)
{
    int          lex_code;
    yyscan_t     scanner;
    void        *parser;
    dbc_state_t  state;
    FILE        *fd;

    if (dbc_scanner_lex_init_extra(&state, &scanner) != 0)
    {
        return NULL;
    }

    fd = fopen(filename, "r");
    if (!fd)
    {
        perror(filename);
        return NULL;
    }

    memset(&state, 0, sizeof(state));
    state.lloc.first_line = 1;
    state.lloc.last_line  = 1;
    state.file            = dbc_new(filename);

    dbc_scanner_set_in(fd, scanner);
    parser = DbcParserAlloc(g_malloc);

#ifdef DBC_TRACE
    DbcParserTrace(stdout, "parser >> ");
#endif

    dbc_printf("%s: Starting parsing\n", G_STRFUNC);

    do
    {
        lex_code = dbc_scanner_lex(scanner);

        if (state.token)
            dbc_printf("%s: Feeding %s = '%s'\n",
                       G_STRFUNC, yyTokenName[lex_code],
                       state.token);
        else
            dbc_printf("%s: Feeding %s\n",
                       G_STRFUNC, yyTokenName[lex_code]);

        DbcParser(parser, lex_code, state.token, &state);

        if (state.parse_error)
            break;
    }
    while (lex_code);

    dbc_printf("%s: Done\n", G_STRFUNC);

    DbcParserFree(parser, g_free);
    dbc_scanner_lex_destroy(scanner);
    dbc_free(state.file);
    fclose(fd);

    if (state.parse_error)
    {
        dbc_printf("%s\n", state.parse_error);
        g_free(state.parse_error);
        return NULL;
    }

    return NULL;
}

int main(int argc, char **argv)
{
    dbc_file_t *dbc;

    if (argc != 2)
        return 1;

    dbc = dbc_read(argv[1]);

    if (!dbc)
        return 0;

    dbc_free(dbc);

    return 0;
}

}
