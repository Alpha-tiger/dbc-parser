%include {

#include <assert.h>
#include <string.h>
#include "dbc-info.h"
#include "dbc_parser_priv.h"

extern void *DbcParserAlloc(void *(*mallocProc)(size_t));
extern void DbcParser(void *yyp, int yymajor, char *yyminor, dbc_state_t *state);
extern void DbcParserFree(void *p, void (*freeProc)(void*));

#ifdef DBC_TRACE
extern void DbcParserTrace(FILE *TraceFILE, char *zTracePrompt);
#endif

#undef NDEBUG

G_GNUC_PRINTF(2, 3)
static void
dbc_warning(dbc_state_t *state, const char *format, ...)
{
    va_list ap;
    va_start(ap, format);
    char *str = g_strdup_vprintf(format, ap);
    va_end(ap);

    state->warnings = g_slist_append(state->warnings, str);
}

G_GNUC_PRINTF(2, 3)
static void
dbc_error(dbc_state_t *state, const char *format, ...)
{
    va_list ap;
    va_start(ap, format);
    char *str = g_strdup_vprintf(format, ap);
    va_end(ap);

    state->errors = g_slist_append(state->errors, str);
}

_Pragma("GCC diagnostic push")
_Pragma("GCC diagnostic ignored \"-Wsign-compare\"")

}

%name DbcParser

%token_prefix TK_

%token_type { gchar * }
%token_destructor
{
    (void)state;
    (void)yypParser;

    g_free($$);
}

%extra_argument { dbc_state_t* state }

%syntax_error
{
    (void)yyminor;

    gboolean first = TRUE;
    GString *msg = g_string_new(NULL);

    g_string_append_printf(
        msg,
        "%d:%d: syntax error: unexpected %s, expecting ",
        state->lloc.first_line,
        state->lloc.first_column,
        yyTokenName[yymajor]);

    for (YYCODETYPE token = 0; token < YYNTOKEN; ++token)
    {
        const YYACTIONTYPE action = yy_find_shift_action(token, yypParser->yytos->stateno);

        if ((action == YY_ACCEPT_ACTION) ||
            (action <= YY_MAX_SHIFT) ||
            ((action >= YY_MIN_SHIFTREDUCE) && (action <= YY_MAX_SHIFTREDUCE)) ||
            ((action >= YY_MIN_REDUCE) && (action <= YY_MAX_REDUCE)))
        {
            if (!first)
                g_string_append(msg, ", ");
            g_string_append(msg, yyTokenName[token]);
            first = FALSE;
        }
    }

    gchar *str = g_string_free(msg, FALSE);
    dbc_error(state, "%s", str);
    g_free(str);
}

%parse_failure
{
    dbc_error(state, "Parse failure");
}

%stack_overflow
{
    dbc_error(state, "Stack overflow");
}

%nonassoc ATTR_ENUM ATTR_FLOAT ATTR_HEX ATTR_INT ATTR_STRING UNKNOWN .

%start_symbol spec

spec ::= version
         new_symbols
         bus_speed
         bus_units
         value_tables
         messages
         message_sender_lists
         environment_variables
         environment_variables_data
         signal_types
         comments
         .

version ::= .
version ::= VERSION TEXT(str) .
{
    state->file->version = str;
}

new_symbols ::= .
new_symbols ::= NS COLON new_symbol_names .

new_symbol_names ::= .
new_symbol_names ::= new_symbol_names new_symbol_name.

new_symbol_name ::= NAME .
new_symbol_name ::= NS_DESC .
new_symbol_name ::= CM .
new_symbol_name ::= VAL .
new_symbol_name ::= VAL_TABLE .
new_symbol_name ::= BA .
new_symbol_name ::= BA_REL .
new_symbol_name ::= BA_DEF .
new_symbol_name ::= BA_DEF_REL .
new_symbol_name ::= BA_DEF_DEF .
new_symbol_name ::= BA_DEF_DEF_REL .
new_symbol_name ::= BU_BO_REL .
new_symbol_name ::= BU_SG_REL .
new_symbol_name ::= BU_EV_REL .
new_symbol_name ::= SIG_VALTYPE .
new_symbol_name ::= SIG_GROUP .
new_symbol_name ::= SG_MUL_VAL .
new_symbol_name ::= BO_TX_BU .
new_symbol_name ::= EV .
new_symbol_name ::= EV_DATA .
new_symbol_name ::= ENVVAR_DATA .
new_symbol_name ::= SGTYPE .
new_symbol_name ::= SIG_TYPE_REF .
new_symbol_name ::= SGTYPE_VAL .
new_symbol_name ::= SIGTYPE_VALTYPE .
new_symbol_name ::= BA_DEF_SGTYPE .
new_symbol_name ::= BA_SGTYPE .
new_symbol_name ::= CAT_DEF .
new_symbol_name ::= CAT .
new_symbol_name ::= FILTER .
new_symbol_name ::= DUMMY_0 .
new_symbol_name ::= DUMMY_1 .
new_symbol_name ::= DUMMY_2 .
new_symbol_name ::= DUMMY_3 .
new_symbol_name ::= DUMMY_8000 .
new_symbol_name ::= DUMMY_8001 .
new_symbol_name ::= DUMMY_8002 .
new_symbol_name ::= DUMMY_8003 .

bus_speed ::= BS COLON .
bus_speed ::= BS COLON uint /*baudrate*/ .
bus_speed ::= BS COLON uint /*baudrate*/ COLON uint /*BTR1*/  COMMA uint /*BTR2*/ .

bus_units ::= BU COLON maybe_names /*node-names*/ .

%type maybe_names { GSList * }
%destructor maybe_names { g_slist_free_full($$, g_free); }

maybe_names(r) ::= .          { r = NULL; }
maybe_names(r) ::= names(v) . { r = v; }

%type names { GSList * }
%destructor names { g_slist_free_full($$, g_free); }

names(r) ::= name(v) .          { r = g_slist_prepend(NULL, v); }
names(r) ::= names(l) name(v) . { r = g_slist_prepend(l, v); }

%type maybe_name { gchar * }
%destructor maybe_name { g_free($$); }

maybe_name(r) ::= .         { r = NULL; }
maybe_name(r) ::= name(v) . { r = v; }

%type name { gchar * }
%destructor name { g_free($$); }

name(r) ::= NAME(v) . { r = v; }
name(r) ::= MUX(v) .  { r = v; }
name(r) ::= DUMMY_0(v) . { r = v; }
name(r) ::= DUMMY_1(v) . { r = v; }
name(r) ::= DUMMY_2(v) . { r = v; }
name(r) ::= DUMMY_3(v) . { r = v; }
name(r) ::= DUMMY_8000(v) . { r = v; }
name(r) ::= DUMMY_8001(v) . { r = v; }
name(r) ::= DUMMY_8002(v) . { r = v; }
name(r) ::= DUMMY_8003(v) . { r = v; }

%type comma_separated_names { GSList * }
%destructor comma_separated_names { g_slist_free_full($$, g_free); }

comma_separated_names(r) ::= name(v) .                                { r = g_slist_prepend(NULL, v); }
comma_separated_names(r) ::= comma_separated_names(l) COMMA name(v) . { r = g_slist_prepend(l, v); }

value_tables ::= .
value_tables ::= value_tables value_table .

value_table ::= VAL_TABLE name values SEMICOLON .

%type values { GArray * }
%destructor values { g_array_free($$, TRUE); }

values(r) ::= .
{
    r = g_array_new(TRUE, TRUE, sizeof(value_string));
    g_array_set_clear_func(r, free_value_string);
}

values(r) ::= values(a) value(v) .
{
    r = g_array_append_val(a, v);
}

%type value { value_string }
%destructor value { free_value_string(&($$)); }

value(r) ::= float(v) TEXT(t) .
{
    r.value  = (gint64)v;
    r.strptr = t;
}

%type uint { guint64 }

uint(r) ::= ZERO .    { r = 0; }
uint(r) ::= ONE .     { r = 1; }
uint(r) ::= TWO .     { r = 2; }
uint(r) ::= UINT(v) . { r = strtoull(v, NULL, 10); g_free(v); }

%type sint { gint64 }

sint(r) ::= uint(v) .       { r = v; }
sint(r) ::= PLUS uint(v) .  { r = v; }
sint(r) ::= MINUS uint(v) . { r = 0 - v; }

%type float { double }

float(r) ::= sint(v) .       { r = v; }
float(r) ::= FLOAT(v) .      { r = strtod(v, NULL); g_free(v); }

messages ::= .
messages ::= messages message .

message ::= BO uint(msg_id) name(msg_name) COLON
            uint(msg_length) name(msg_sender)
            signals(msg_signals)
            .
{
    dbc_message_t *msg;

    msg = g_new0(dbc_message_t, 1);

    msg->id      = msg_id;
    msg->name    = msg_name;
    msg->length  = msg_length;
    msg->senders = msg_sender;
    msg->signals = msg_signals;

    if (strlen(msg->name) > DBC_MAX_MESSAGE_LENGTH)
    {
        dbc_warning(state,
                    "warning: message %u '%s': Name is longer than %u symbols",
                    msg->id,
                    msg->name,
                    DBC_MAX_MESSAGE_LENGTH);
    }

    state->file->messages = g_slist_prepend(state->file->messages, msg);
}

%type signals { GSList * }
%destructor signals { g_slist_free_full($$, (GDestroyNotify)dbc_free_signal); }

signals(r) ::= .                      { r = NULL; }
signals(r) ::= signals(l) signal(v) . { r = g_slist_prepend(l, v); }

%type signal { dbc_signal_t * }
%destructor signal { dbc_free_signal($$); }

signal(r) ::= SG name(sig_name) mux COLON
              uint(sig_start) PIPE uint(sig_length) AT
              endianess(sig_endianess) signess(sig_signess)
              LEFT_PARENTHESIS float(sig_factor) COMMA float(sig_offset) RIGHT_PARENTHESIS
              LEFT_BRACKET float(sig_min) PIPE float(sig_max) RIGHT_BRACKET
              TEXT(sig_unit) comma_separated_names
              .
{
    r = g_new0(dbc_signal_t, 1);

    r->name      = sig_name;
    r->start     = sig_start;
    r->length    = sig_length;
    r->signess   = sig_signess;
    r->endianess = sig_endianess;
    r->factor    = sig_factor;
    r->offset    = sig_offset;
    r->min       = sig_min;
    r->max       = sig_max;
    r->unit      = sig_unit;
    r->type      = DBC_SIGNAL_TYPE_INT;
}

mux ::= .
mux ::= MUX .

%type endianess { dbc_signal_endianess_t }
endianess(r) ::= ZERO . { r = DBC_SIGNAL_ENDIANESS_MOTOROLA; }
endianess(r) ::= ONE .  { r = DBC_SIGNAL_ENDIANESS_INTEL; }

%type signess { dbc_signal_signess_t }
signess(r) ::= PLUS .  { r = DBC_SIGNAL_SIGNESS_UNSIGNED; }
signess(r) ::= MINUS . { r = DBC_SIGNAL_SIGNESS_SIGNED; }

message_sender_lists ::= .
message_sender_lists ::= message_sender_lists message_sender_list .

message_sender_list ::= BO_TX_BU uint(msg_id) COLON
                        comma_separated_names(msg_senders) SEMICOLON
                        .
{
    dbc_message_t *msg = dbc_find_message(state->file, msg_id);

    if (msg)
    {
        GArray   *arr = g_array_sized_new(TRUE, TRUE, sizeof(gchar *), g_slist_length(msg_senders));
        unsigned  i   = 0;
        gchar    *senders_str;

        /* TODO: Check if we need to keep the original sender name */
        for (GSList *elem = msg_senders; elem; i++, elem = g_slist_next(elem))
            g_array_insert_val(arr, i, elem->data);

        senders_str = g_strjoinv(" | ", (gchar **)arr->data);
        g_array_free(arr, TRUE);
        g_free(msg->senders);
        msg->senders = senders_str;
    }
    else
    {
        dbc_error(state, "Message with id %" G_GINT64_FORMAT " not found", msg_id);
    }

    g_slist_free_full(msg_senders, g_free);
}

environment_variables ::= .
environment_variables ::= environment_variables environment_variable .

environment_variable ::= EV name COLON value_type
                         LEFT_BRACKET float /*min*/ PIPE float /*max*/ RIGHT_BRACKET
                         TEXT /*unit*/ float /*default*/ uint /*id*/
                         dummy_name /*access-rights*/ comma_separated_names /*ecus*/
                         SEMICOLON
                         .

%type value_type { dbc_value_type_t }

value_type(r) ::= ZERO . { r = DBC_SIGNAL_TYPE_INT; }
value_type(r) ::= ONE .  { r = DBC_SIGNAL_TYPE_FLOAT; }
value_type(r) ::= TWO .  { r = DBC_SIGNAL_TYPE_DOUBLE; }

dummy_name ::= DUMMY_0 .
dummy_name ::= DUMMY_1 .
dummy_name ::= DUMMY_2 .
dummy_name ::= DUMMY_3 .
dummy_name ::= DUMMY_8000 .
dummy_name ::= DUMMY_8001 .
dummy_name ::= DUMMY_8002 .
dummy_name ::= DUMMY_8003 .

environment_variables_data ::= .
environment_variables_data ::= environment_variables_data environment_variable_data .

environment_variable_data ::= ev_data_tag name COLON uint /*length*/ SEMICOLON .

ev_data_tag ::= ENVVAR_DATA .
ev_data_tag ::= EV_DATA .

signal_types ::= .
signal_types ::= signal_types signal_type.

signal_type ::= SGTYPE name COLON uint /*length*/ AT endianess signess
                LEFT_PARENTHESIS float /*factor*/ COMMA float /*offset*/ RIGHT_PARENTHESIS
                LEFT_BRACKET float /*min*/ PIPE float /*max*/ RIGHT_BRACKET
                TEXT /*unit*/ float /*default-value*/
                maybe_name /*value-table*/ SEMICOLON
                .

comments ::= .
comments ::= comments comment .

comment ::= CM BU name TEXT SEMICOLON .
comment ::= CM EV name TEXT SEMICOLON .

comment ::= CM TEXT(text) SEMICOLON .
{
    if (state->file->comment)
    {
        g_free(state->file->comment);
        dbc_warning(state, "warning: File comment redefined");
    }

    state->file->comment = text;
}

comment ::= CM BO uint(msg_id) TEXT(text) SEMICOLON .
{
    dbc_message_t *msg = dbc_find_message(state->file, msg_id);

    if (msg)
    {
        if (msg->comment)
        {
            g_free(msg->comment);
            dbc_warning(state, "warning: Message %" G_GINT64_FORMAT " comment redefined", msg_id);
        }

        msg->comment = text;
    }
    else
    {
        g_free(text);
        dbc_error(state, "error: Message %" G_GINT64_FORMAT " not found", msg_id);
    }
}

comment ::= CM SG uint(msg_id) name(sig_name) TEXT(text) SEMICOLON .
{
    dbc_signal_t *sig = dbc_find_signal(state->file, msg_id, sig_name);

    if (sig)
    {
        if (sig->comment)
        {
            g_free(sig->comment);
            dbc_warning(state, "warning: Signal %s message %" G_GINT64_FORMAT " comment redefined",
                        sig_name, msg_id);
        }

        sig->comment = text;
    }
    else
    {
        g_free(text);
        dbc_error(state, "error: Signal %s in message %" G_GINT64_FORMAT " not found",
                  sig_name, msg_id);
    }

    g_free(sig_name);
}

%code {

_Pragma("GCC diagnostic pop")

#include "dbc_scanner_lex.h"
#include "dbc_parser.h"

dbc_file_t *dbc_read(const gchar *filename)
{
    int          lex_code;
    yyscan_t     scanner;
    void        *parser;
    dbc_state_t  state;
    FILE        *fd;

    if (dbc_scanner_lex_init_extra(&state, &scanner) != 0)
    {
        return NULL;
    }

    fd = fopen(filename, "r");
    if (!fd)
    {
        perror(filename);
        return NULL;
    }

    memset(&state, 0, sizeof(state));
    state.lloc.first_line = 1;
    state.lloc.last_line  = 1;
    state.file            = dbc_new(filename);

    dbc_scanner_set_in(fd, scanner);
    parser = DbcParserAlloc(g_malloc);

#ifdef DBC_TRACE
    DbcParserTrace(stdout, "parser >> ");
#endif

    dbc_printf("%s: Starting parsing\n", G_STRFUNC);

    do
    {
        lex_code = dbc_scanner_lex(scanner);

        if (state.token)
            dbc_printf("%s: Feeding %s = '%s'\n",
                       G_STRFUNC, yyTokenName[lex_code],
                       state.token);
        else
            dbc_printf("%s: Feeding %s\n",
                       G_STRFUNC, yyTokenName[lex_code]);

        DbcParser(parser, lex_code, state.token, &state);

        if (state.errors)
            break;
    }
    while (lex_code);

    dbc_printf("%s: Done\n", G_STRFUNC);

    DbcParserFree(parser, g_free);
    dbc_scanner_lex_destroy(scanner);
    fclose(fd);

    if (state.warnings)
    {
        for (GSList *elem = state.warnings; elem; elem = g_slist_next(elem))
            dbc_printf("%s\n", (gchar *)elem->data);
        g_slist_free_full(state.warnings, g_free);
    }

    if (state.errors)
    {
        for (GSList *elem = state.errors; elem; elem = g_slist_next(elem))
            dbc_printf("%s\n", (gchar *)elem->data);
        g_slist_free_full(state.errors, g_free);
        dbc_free(state.file);
        return NULL;
    }

    return state.file;
}

int main(int argc, char **argv)
{
    dbc_file_t *dbc;

    if (argc != 2)
        return 1;

    dbc = dbc_read(argv[1]);

    if (!dbc)
        return 2;

    dbc_free(dbc);

    return 0;
}

}
